char指针与char数组的区别（非常详细！）
http://blog.csdn.net/johnny710vip/article/details/6725637

首先看指针:
char *p = “helloworld”;
    在这里p是一个变量,其类型为指针类型,并且指向一个字符串,字符串内容为”helloworld”,如果要访问p[2]的话,就需要先从p中取出地址,该地址为”helloworld”的首地址,然后再加上偏移量2,就得到了’l’这个字符,所以其访问的方式为先从p中取出地址,然后再将该地址加上偏移量,得到一个地址,最后从这个地址中取出值来。其分为三步:
1.取p的值,该值即为字符串的首地址；
2.该地址加上偏移量,得到所要取的字符的地址；
3.从这个地址中取得值。
此处p是一个变量,它自己是存放在一个地址中的,而它的内容则是”helloworld”这个字符串的地址. p与字符串是分开的。
    同时,该指针的值是动态确定的,必须在运行的时候才能确定其值,并通过该值访问到字符串。
    而如果是数组的话,则为
char p[20] = “helloworld”;
    在这里p为一个字符串的标识,其类型是一个字符数组的类型,且该数组有20个char类型的大小.此时如果要访问p[2]的话,分2步：
1.直接使用该字符数组的首地址加上2个char类型的大小的长度就得到了要访问的字符的地址；
2.最后再从这个地址中取出值来.而且此时p的地址为该字符数组的首地址,其内容为’h’，一个字符类型。
    所以在这个地方数组与指针是不相同的,因为此时数组取值的第一步并不是从p中读取地址来再加上偏移量的.此时的p这个地址的值就为’h’这个字符,其类型为字符型而不是一个指针类型.此时p的地址与p[0]的地址是相同的。
    同时,每个符号的地址在编译时就确定了,所以这里p的地址就已经确定了,如果需要访问p[2],则直接使用该地址加上2这个偏移量就可以取到这个值了.它不需要指令再取得这个首地址.而第一种情况下,还需要指令取得指针中的值,并通过这个值来访问字符串。
    一个直观的看法就是前一种是两个不同的, 而后一种则是在同一个里面。
    另外，还有一个不同之处在于第一个情况下 p 指向的是一个常量区, 是不能改变的, 即不能够对p[i]赋值, 而第二种情况下, p是一个字符数组, 其是可以改变的，可以对p[i]赋值的。
  他们俩*p的值是一样的，都是h字符！
